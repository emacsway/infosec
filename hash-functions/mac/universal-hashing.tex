\subsection{Универсальное хеширование}\label{sec:universal-hashing}
\selectlanguage{russian}
Наличие одного единственного правила хеширования может привести к тому, что злоумышленник, зная точную формулу вычисления хеша, сможет подобрать такой набор входных данных, который с большой степенью вероятности даёт коллизии обычной (не криптографической) хеш-функции. Кроме того, сами хеш-функции также разрабатываются исходя из определённого предположения о входных данных. Алгоритмы хеширования могут содержать некоторые константы, которые разработчику информационной системы предлагается выбрать самостоятельно, основываясь на его предположениях об особенностях входных данных. Но квалификации разработчика, либо его априорных знаний, может не хватать для эффективного выбора конкретной реализации (алгоритм и параметры) хеширования. Исходя из этого Картер и Вегман в 1979 году (\langen{John Lawrence Carter, Mark N. Wegman}, \cite{Carter:Wegman:1979}) предложили определить класс алгоритмов хеширования с возможностью выбора одного из них непосредственно в момент вызова.

Обозначим через $\delta$ возможный факт совпадения значения некоторой унарной функции для некоторых значений аргументов:

\[
\delta_{f}( x, y ) = \left\{\begin{matrix}
1, & f(x) = f(y);\\ 
0, & f(x) \neq f(y).
\end{matrix}\right.
\]

Пусть $H$ -- класс функций, преобразующих $M \to R$. Будем называть класс $H$ универсальным$_{2}$, если

\[
\forall x, y \in M: \sum_{h \in H} \delta_{h}( x, y ) \leq |H| / |R|.
\]

То есть класс функций $H$ универсален$_{2}$, если для любых пар аргументов $x$ и $y$ значения функций совпадают не более чем для $1/|R|$-ой части функций из множества $H$. Нижний индекс <<$_{2}$>> подчёркивает тот факт, что речь идёт о совпадении значений только для пар элементов. В дальнейшем мы его будем опускать.

Примеры универсальных классов для хеширования:\footnote{Универсальность первых двух примеров была показана ещё в работе Картера и Вегмана~\cite{Carter:Wegman:1979}. Последний описан, например, в~\cite{Dietzfelbinger:Gil:Matias:Pippenger:1992}.}

\begin{itemize}
    \item функции хеширования для чисел $x$
    \[ \begin{array}{l}
    h(x) = ax + b \bmod p,\\
    a \in \Z^*_p, b \in \Z_p;\\
    \end{array} \]
    \item функции хеширования для векторов $\vec{x}$
    \[ \begin{array}{l}
    \vec{x} = \left \langle x_0, x_1, \dots, x_r \right \rangle,\\
    \vec{a} = \left \langle a_0, a_1, \dots, a_r \right \rangle,\\
    \forall i \in \Z_{r+1}: a_i \in \Z_{p},\\
    h( \vec{x} ) = \sum_{i=0}^{r} a_i x_i \bmod p;\\
    \end{array} \]
    \item функции хеширования для строк (последовательностей переменной длины) $\vec{x}$
    \[ \begin{array}{l}
    \vec{x} = \left \langle x_0, x_1, \dots, x_l \right \rangle,\\
    \forall x_i: x_i \in \Z_{u}, \\
    p \geq u, \\
    a \in \Z_{p}, a \neq 0,\\
    h( \vec{x} ) = \sum_{i=0}^{l} a^{i} x_i \bmod p.\\
    \end{array} \]
\end{itemize}

На основе универсального хеширования построены такие криптографические примитивы, как UMAC и Poly1305 (RFC 8439).
