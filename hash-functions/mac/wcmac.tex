\subsection{Конструкция Вегмана-Картера}
\selectlanguage{russian}

В 1981 году Вегман и Картер предложили (\cite{Wegman:Carter:1981}) использовать универсальное хэширование (раздел~\ref{sec:universal-hashing}) для построение алгоритмов имитовставок. В оригинале авторы предполагали, что каждое сообщение содержит неповторяющийся номер $i$, а секретный ключ между отправителем и получателем состоит из двух частей:

\begin{itemize}
    \item параметра $k_1$, задающего способ выбора функции из универсального класса хэширования $H: K \times A \to B$;
    \item параметра $k_2$, который представлял собой \emph{последовательность} строк $b_1, b_2, \dots, b_n$.
\end{itemize}

Размер элемента множества $B$ и каждой из строк $b_1, b_2, \dots, b_n$ совпадают. Результатом вычисления имитовставки является:

\[ \begin{array}{l}
    m' = \langle i, m \rangle,\\
    \textrm{MAC} (m') = H_{k_1}(m) \oplus b_i.
\end{array} \]

Авторы показали надёжность данной схемы при условии случайного выбора ключей и универсальности класса хэширования. Однако с практической точки зрения использовать ключи, состоящие из \emph{последовательностей} очень непрактично. Более того, можно было передать столько сообщений, сколько элементов последовательности задано в $k_2$. Для передачи сообщения сверх этого лимита нужно было либо расширить существующий ключ, либо сгенерировать новый.

Поэтому сейчас вместо использования последовательности строк $b_1, b_2, \dots, b_n$ в качестве ключа предполагается наличие некоторого класса псевдослучайных функций (\langen{pseudorandom function family, PRF}), который эмулирует \emph{случайного оракула}. В своей идеализированной модели он для каждого некоторого входа может выдать ответ, случайно распределённой по области значений. Однако если на вход случайного оракула будет подано уже ранее подававшееся значение, он должен выдать прежний ответ. Входом этого оракула являются, во-первых, некоторое случайное число $r$, которое заменило собой номер сообщения, во-вторых часть общего секретного ключа $k_2$, которая будет служить для выбора конкретной функции из класса псевдослучайных.

В качестве практической реализации такого класса функций могут, с некоторым приближением, выступать другие реализации имитовставок, даже если они медленно работают. Например, основанные на криптографических хэш-функциях или блочных шифрах. Потому что им на вход (в отличие от быстрой функции универсального хэширования) подаётся только небольшой блок информации -- случайное число $r$.

Таким образом, современную конструкцию Вегмана-Картера можно описать так. Пусть выбран некоторый класс универсальных хэш-функций (например, в качестве него можно использовать одноразовую имитовставку из раздела~\ref{sec:one-time-mac}) \[
    H: \{0,1\}^{|k_1|} \times \{0,1\}^* \to \{0,1\}^n,
\] и некоторая надёжная реализация медленной имитовставки \[
    PRF: \{0,1\}^{|k_2|} \times \{0,1\}^{|r|} \to \{0,1\}^n.
\]

Тогда получение быстрой имитовставки можно сделать следующим образом
\[ \begin{array}{l}
\textrm{secret key: } k: \langle k_1, k_2 \rangle,\\
\textrm{random nonce: } r \leftarrow {0,1}^n,\\
\textrm{MAC} (m) = \langle r, H_{k_1}(m) \oplus PRF_{k_2}(r) \rangle.
\end{array} \]

Как утверждается в~\cite{Krovetz:2000}, использование данной конструкции позволяет достичь скорости хэширования в $0{,}5$ циклов процессора на один байт сообщения (\langen{cycles per byte, cpb}).
